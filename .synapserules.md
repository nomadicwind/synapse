# Synapse Development Rules & Guidelines

## Core Principles (From Product Design)

### 1. Zero-Friction Capture
- Prioritize user experience for capturing information
- Ensure capture actions are near-instantaneous
- Minimize cognitive load for users
- Design for one-click/tap capture wherever possible

### 2. Asynchronous by Design
- Decouple user-facing actions from backend processing
- Always provide immediate feedback to users
- Use 202 Accepted responses for capture requests
- Implement proper loading states in UI

### 3. Standardized Output
- Maintain consistent data structure across all input types
- Ensure output includes: textual content, metadata, linked media assets
- Follow defined schema for KnowledgeItem and ImageAsset entities
- Validate data before persistence

### 4. Content over Container
- Focus on extracting core knowledge (text, images)
- Don't prioritize preserving original formatting/containers
- Convert all inputs to standardized text-based format
- Discard temporary files after processing

## Technical Guidelines (From Technical Design)

### 5. Architecture & Infrastructure
- Use Docker for all services (API, Worker, DB, Redis, MinIO, STT)
- Follow containerization best practices
- Implement proper service communication patterns
- Use environment variables for configuration

### 6. Backend Development
- Use FastAPI with Pydantic for request validation
- Implement JWT authentication for all endpoints
- Use Celery with Redis for asynchronous task processing
- Follow error handling patterns: try/except with status updates
- Implement structured logging across all services

### 7. Database & Storage
- Use PostgreSQL with Alembic for migrations
- Follow defined schema for knowledge_items and image_assets tables
- Use MinIO for local development, S3-compatible for production
- Implement proper indexing for performance

### 8. Frontend Development
- Use React Native with Expo for cross-platform development
- Implement NativeWind for Tailwind CSS styling
- Use Zustand or Redux Toolkit for state management
- Store JWT tokens securely with Expo SecureStore
- Implement proper loading states for asynchronous operations

### 9. Testing Requirements
- Write unit tests for all critical functions (Pytest for backend, Jest for frontend)
- Implement integration tests for service interactions
- Create end-to-end tests for core user flows
- Test error scenarios and edge cases
- Aim for 80%+ test coverage

### 10. Code Quality & Maintenance
- Follow consistent code style (use linters and formatters)
- Write clear, descriptive commit messages
- Document complex logic and decisions
- Keep dependencies updated and secure
- Review code for performance bottlenecks

## Development Workflow

### 11. Branching Strategy
- Use main branch for production-ready code
- Use develop branch for integration
- Create feature/* branches for new development
- Use fix/* branches for bug fixes
- Create release/* branches for version releases

### 12. Pull Request Process
- Require at least one reviewer for all PRs
- Ensure all tests pass before merging
- Update documentation when code changes
- Follow semantic versioning for releases
- Conduct code reviews focusing on architecture, performance, and security

### 13. Deployment & Monitoring
- Implement health checks for all services
- Set up monitoring and alerting (Prometheus/Grafana)
- Create deployment scripts for staging and production
- Implement proper rollback procedures
- Monitor system performance and resource usage

## AI-Specific Guidelines

### 14. For AI-Assisted Development
- Follow project architecture and design decisions
- Maintain consistency with existing code patterns
- Prioritize readability and maintainability over clever solutions
- Document any AI-generated code with rationale
- Verify AI suggestions against project requirements
- Test AI-generated code thoroughly before integration
- Respect user privacy and data security requirements
- Optimize for developer velocity while maintaining quality
